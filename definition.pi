# all types except 'any' are defined in code
typename:
   (.word | "any")
   "[" type "]"

type:
   typename ":"


# token types are indicated with . (dot) prefix
derefer:
   "[" expr ("," expr)? "]"

atom:
   .word | .number | .string | derefer | func_call

op_unary:
   "not" | "-" | "~" | type #cast

# symbols are taken by character because the lexer produces individual symbols not groups
op_binary:
   "."
   "*" | "/" | "%"
   "+" | "-"
   "<<" | ">>"
   ">" | "<" | ">=" | "<="
   "==" | "!="
   "&"
   "^"
   "|"
   "and"
   "or"

op_assign:
   "=" | "*=" | "/=" | "+=" | "-=" | "%=" | "|=" | "&=" | "^=" | ">>=" | "<<="

precedence:
   "."   #member access
   "[]"  #dereference
   op_unary
   "*" | "/" | "%"
   "+" | "-"
   "<<" | ">>" # bitwise shift
   ">" | "<" | ">=" | "<="
   "==" | "!="
   "&"   #bitwise and
   "^"   #bitwise xor
   "|"   #bitwise or
   "and"
   "or"
   op_assign


expr:
   op_unary? atom (operator expr)?
   "(" expr ")"
   "(" assign ")"

declare:
   type .word op_assign expr

assign:
   .word op_assign expr

if:
   "if" expr chunk ("elif" expr chunk)* ("else" chunk)?

while:
   "while" expr chunk

break:
   "break"

continue:
   "continue"


params:
   "(" ( type .word ("," type .word)* )? ")"

args:
   "(" ( expr ("," expr)* )? ")"

func_def:
   type .word params chunk

func_call:
   .word args

return:
   "return" expr?

statement:
   assign
   if
   while
   break
   continue
   func_call
   return

chunk:
   .newline .indent statement (.newline statement)* .dedent

program:
   statement (.newline statement)*

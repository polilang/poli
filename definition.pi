# all types except 'any' are defined in code
type:
   (.word | "any")
   "[" type "]"

# token types are indicated with . (dot) prefix
derefer:
   "[" expr ("," expr)? "]"

atom:
   .word | .number | .string | derefer | func_call

op_unary:
   "not" | "-"

# symbols are taken by character because the lexer produces individual symbols not groups
operator:
   "."
   "~"
   "*" | "/" | "%"
   "+" | "-"
   "<""<" | ">"">"
   ">" | "<" | ">""=" | "<""="
   "=""=" | "!""="
   "&"
   "^"
   "|"
   "and"
   "or"

op_assign:
   "=" | "*""=" | "/""=" | "+""=" | "-""=" | "%""=" | "|""=" | "&""=" | "^""=" | ">"">""=" | "<""<""="

expr:
   op_unary? atom (operator expr)?
   "(" expr ")"
   "(" assign ")"

declare:
   type ":" .word op_assign expr

assign:
   .word op_assign expr

if:
   "if" expr .newline .indent chunk .dedent ("elif" expr .newline .indent chunk .dedent)* ("else" .newline .indent chunk .dedent)?

while:
   "while" expr .newline .indent chunk .dedent

break:
   "break"

continue:
   "continue"


params:
   "(" ( type ":" .word ("," type ":" .word)* )? ")"

args:
   "(" ( expr ("," expr)* )? ")"

func_def:
   type ":" .word params .newline .indent chunk .dedent

func_call:
   .word args

return:
   "return" expr?

statement:
   assign | if | while | break | continue | func_call | return

chunk:
   statement (.newline statement)*


###
   Poli programming language
   syntax example
###



# --- datatypes, expressions, assignment

# static typing
i32 someint = 123 * (16 + 2)

# pointers/references
i32* ptr = :someint # i32 *ptr = &(someint);
ptr := 15 * someint

# dynamic typing
var dynamic = "string"

# dynamic pointers
var dptr := dynamic # var *dptr = &dynamic;
:dptr = 12345

# arrays
i32 [5] arr := [1, 2, 3, 4, 5] # i32 arr[5] = {1, 2, 3, 4, 5};

# automatic sizing
i32 [] auto := [5, 4, 3, 2] # i32 auto[] = {5, 4, 3, 2};

# pointers to arrays
i32 p_auto := auto
p_auto[0] = 6
:p_auto = 6

# dynamic arrays with automatic size
[] dynauto := [2, 2.4, "what", auto]

# casting
i32 cast := 2.4564 as i32

# splitting a type into bytes by casting; union exploit
u08[4] bsplit := 123452 as u32 as i08[]


# --- functions

# typed function, returns i64
i64 sum {i32 a, i32 b}
   return a + b


# can return anything
countdown {i32 i}
   for j in range i
      print j


# functions taking pointers
modify {u64* thing}
   thing := 12345


# typed function, returns i64
i64 sum {i32 a, i32 b}
   return a + b


# one liner with return type; return implied
u32 factorial {u32 i} i and (factorial(i-1) * i) or 1


# one liner can return anything; return implied
is_white_space {u08 c} list(' ', '\n', '\r', '\t').has(c)


# function calls
factorial(5)



# --- object orientation

# simple class
Vector2:

   # declare all members here
   i32 x, y


   # initializer with overloading
   new {self, i32 x, i32 y}
      # "." is sugar for the first argument in the function
      .x := x
      .y := y


   new {self, Vector2 v}
      .x := v.x
      .y := v.y


   # operators with overloading
   add {self, Vector2 other}
      .x := .x + other.x
      .y := .y + other.y


   add {self, list other}
      .x := .x + other[0]
      .y := .y + other[1]


   add {self, i32 x, i32 y}
      .x := .x + x
      .y := .y + y


# creating an instance
Vector2 vec = Vector2(1, 2)



# preprocessor templates
template {for <word:type>? <word:item> in <expression:iterable> <newline> <block:body>}
   (
      iterator := iterable
      type item

      while item := iterator.next()
         body
   )



# modules and imports

with mymodule
with mymodule.submodule
